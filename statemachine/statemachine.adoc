= Spring State Machine
:source-highlighter: prettify
:icons: font
:toc:
:experimental:
:numbered:
:homepage: http://antkorwin.com
Korovin Anatoliy <antkorwin@gmail.com>;  Home <http://antkorwin.com>
// START OF CONTENT

## Dependencies

Create a new SpringBoot project and add statemachine in dependencies.

image:./spring-init.png[state machine]

One starter made all the magic

[source, xml]
----
<dependency>
	<groupId>org.springframework.statemachine</groupId>
	<artifactId>spring-statemachine-starter</artifactId>
</dependency>
----

## States & Events

For example, consider the business process known to most developers.
If you didn't hear about kanban before, then you should read about this methodology.
You can find many articles about it on the Internet.

Let's see the following scheme:

[plantuml]
....
[*] --> BACKLOG : business team gave new tasks
BACKLOG --> INPROGRESS : developer started feature
INPROGRESS --> TESTING : developer finished feature
TESTING -->DONE : QA-team checked the use case and marked it as successful
TESTING --> INPROGRESS : QA-team found a bugs and rejected the use case
DONE --> [*]
....

We can extract the following states from this business-process: `BACKLOG`,
`IN_PROGRESS`, `TESTING`, `DONE`. This will be our set of states.
The transition from one state to another passes by a certain event.

Spring statemachine provides the ability to configure through enums.
You can describe states and events in enumeration:

[source, java]
----
public enum States {
    BACKLOG,
    IN_PROGRESS,
    TESTING,
    DONE
}

public enum  Events {
    START_FEATURE,
    FINISH_FEATURE,
    QA_REJECTED_UC,
    ROCK_STAR_DOUBLE_TASK,
    DEPLOY,
    QA_CHECKED_UC
}
----

## Configuration

We will consider an example of using a statemachine through the use of standard spring DI.
We need to make a spring configuration for the state machine:

[source, java]
----
@Configuration
@EnableStateMachine
public class StateMachineConfig
        extends EnumStateMachineConfigurerAdapter <1>
                        <States, Events> {

    @Override
    public void configure(
            StateMachineConfigurationConfigurer
                    <States, Events> config) throws Exception {

        config.withConfiguration()  <2>
              .autoStartup(true);
    }


    @Override
    public void configure(
            StateMachineStateConfigurer<States, Events> states)
            throws Exception {

        states.withStates()		<3>
              .initial(States.BACKLOG)
              .state(States.IN_PROGRESS)
              .state(States.TESTING)
              .end(States.DONE);
    }

    @Override
    public void configure(
            StateMachineTransitionConfigurer<States, Events> transitions)
            throws Exception {

        transitions.withExternal()  <4>
                   .source(States.BACKLOG)
                   .target(States.IN_PROGRESS)
                   .event(Events.START_FEATURE)
                   .and()
                   .withExternal()
                   .source(States.IN_PROGRESS)
                   .target(States.TESTING)
                   .event(Events.FINISH_FEATURE)
                   .and()
                   .withExternal()
                   .source(States.TESTING)
                   .target(States.IN_PROGRESS)
                   .event(Events.QA_TEAM_REJECT)
                   .and()
                   .withExternal()
                   .source(States.TESTING)
                   .target(States.DONE)
                   .event(Events.QA_TEAM_APPROVE);
    }
----
<1> we working with a type-safe, all of our states and events are described by the enums, so these types will be declared in the configuration.
<2> override base method for configuring the state machine.
<3> description of states
<4> description of transitions

We set the autostart setting in the base configuration,
then the state machine will start immediately in the initialization state.

You need to specify the entry point to the state machine (the initial state) in the settings of states.
When the state machine is start, the transition to this point will be the first.

It is important to understand that the transition to the `BACKLOG` state from "nowhere" is also a transition, a little later we will see it more clearly.

Also, we specify the exit point (end state) in the configuration of states.
Transition to this state will stop the state machine.

The configuration of the transitional looks pretty intuitive,
for each transition you need to specify the initial state,
the target state, and the event that will triggered this transition.


## Try to use it

Test successful DI & initialization of state machine

[source, java]
----
@RunWith(SpringRunner.class)
@SpringBootTest
public class StatesFirstApplicationTests {

    @Autowired
    private StateMachine<States, Events> stateMachine;

    @Test
    public void initTest() {
        Assertions.assertThat(stateMachine.getState().getId())
                  .isEqualTo(States.BACKLOG);

        Assertions.assertThat(stateMachine).isNotNull();
    }
}
----

We test the main flow of the application, when execution is on a positive way ("green way"):


[source, java]
----
@Test
public void testGreenFlow() {
    // Arrange
    // Act
    stateMachine.sendEvent(Events.START_FEATURE);
    stateMachine.sendEvent(Events.FINISH_FEATURE);
    stateMachine.sendEvent(Events.QA_TEAM_APPROVE);
    // Asserts
    Assertions.assertThat(stateMachine.getState().getId())
              .isEqualTo(States.DONE); <1>
}
----
<1> The main criterion for the successful completion of all transitions
is the achievement by the state machine of state DONE.
In a real test, it would be worthwhile to check each transition,
not only the final state after a series of transitions,
but for our research purposes this will be enough.


## Intercept the events of the state machine

Add state machine listener in configuration:

[source, java]
----
@Override
public void configure(
				StateMachineConfigurationConfigurer
								<States, Events> config) throws Exception {

		config.withConfiguration()
					.listener(listener()) <1>
					.autoStartup(true);
}

private StateMachineListener<States, Events> listener() {
		return new StateMachineListenerAdapter<States, Events>(){
				@Override
				public void transition(Transition<States, Events> transition) { <2>
						log.warn("move from:{} to:{}",
										 ofNullableState(transition.getSource()),
										 ofNullableState(transition.getTarget()));
				}

				@Override
				public void eventNotAccepted(Message<Events> event) { <3>
						log.error("event not accepted: {}", event);
				}

				private Object ofNullableState(State s) {
						return Optional.ofNullable(s)
													 .map(State::getId)
													 .orElse(null);
				}
		};
}
----
<1> declaration of listener
<2> override callback for intercept any transitions
<3> override callback for attempt of unacceptable transitions

after that we can make "wrong way" test:

[source, java]
----
@Test
public void testWrongWay() {
    // Arrange
    // Act
    stateMachine.sendEvent(Events.START_FEATURE);
    stateMachine.sendEvent(Events.QA_TEAM_APPROVE);
    // Asserts
    Assertions.assertThat(stateMachine.getState().getId())
              .isEqualTo(States.IN_PROGRESS);
}
----

then we look at logout error:

image::wrong_way_test.png[wrong way test result]

This is a clear example of what I said before,
the starting transition from "nowhere" to `BACKLOG` is also a transition.
We should use the method `ofNullableState`
because the source state in this transition is `null`.


## More than one state machine? No problem!

change annotation `@EnableStateMachine` to `@EnableStateMachineFactory`,
this provide us the ability to create state machine from factory
and we can inject factory instead of concrete instance.

[source, java]
----
@Slf4j
@Configuration
@EnableStateMachineFactory
public class StateMachineConfig
        extends EnumStateMachineConfigurerAdapter
                        <States, Events> {

								...

}
----

and now we need to change the tests:

[source,java]
----
@RunWith(SpringRunner.class)
@SpringBootTest
public class StatesFirstApplicationTests {

    private StateMachine<States, Events> stateMachine;

    @Autowired
    private StateMachineFactory<States, Events> stateMachineFactory;

    @Before
    public void setUp() throws Exception {
        stateMachine = stateMachineFactory.getStateMachine();
    }

		...
}
----

## Actions - add some business logic

Let's make auto-deploy after the finished feature.

We can do this as follows:

[source,java]
----
@Override
public void configure(StateMachineStateConfigurer<States, Events> states)
				throws Exception {

		states.withStates()
					.initial(States.BACKLOG)
					.state(States.IN_PROGRESS)
					.state(States.TESTING, deployAction()) <1>
					.end(States.DONE);
}

private Action<States, Events> deployAction() {  <2>
		return context -> {
				log.warn("DEPLOYING: {}",context.getEvent());
		};
}
----
<1> add deploy action after enter in TESTING state
<2> implementation of Deploy action

This approach has one problem.
If we slightly complicate our business process, then this action can be performed when it is unnecessary.
For example, if the developer has finished two features in one pull-request, then he can transfer the second task without additional deployment.
We will assume that he maked this because he is super efficient and we can call him a "Rock Star".

[plantuml]
....
[*] --> BACKLOG : time to work!

BACKLOG --> IN_PROGRESS : start feature

IN_PROGRESS --> TESTING : finish feature

TESTING --> DONE : QA approved

TESTING --> IN_PROGRESS : QA rejected task

BACKLOG --> TESTING : Rock Star
....

Now if we move task from backlog to testing then will be run deploy.
But we don't want this behavior.

Add rock star transition in configuration:

[source, java]
----
transitions.withExternal()
           		...
           .and()
           .withExternal()
           .source(States.BACKLOG)
           .target(States.TESTING)
           .event(Events.ROCK_STAR_MAKE_ALL_IN_ONE);
----
check behavior in test:

[source,java]
----
@Test
public void testRockStar() {
    // Arrange
    // Act
    stateMachine.sendEvent(Events.ROCK_STAR_MAKE_ALL_IN_ONE);
    // Asserts
    Assertions.assertThat(stateMachine.getState().getId())
              .isEqualTo(States.TESTING);
}
----

test results:

image::deploying_test_result.png[rock star test result]

Now we can see that the `deployAction` is triggered by any transition to the state `TESTING`.

How can we solve this problem? We can move the action
from the states to transitions configuration:

[source, java]
----
states.withStates()
      .initial(States.BACKLOG, timeToWorkAction())
      .state(States.IN_PROGRESS) <1>
      .state(States.TESTING)
      .end(States.DONE);

  ...

transitions.withExternal()
           	...
           .source(States.IN_PROGRESS)
           .target(States.TESTING)
           .event(Events.FINISH_FEATURE)
           .action(deployAction())  <2>
           .and()
           	...
----
<1> remove deploying action from states
<2> past the action on transition from IN_PROGRESS to FINISH_FEATURE

## Guards - use conditions in flow.

Next we will add the ability to run deploying from `BACKLOG` and `IN_PROGRESS` states.
We will make `DEPLOY` a separate event so that the developers themselves can decide when to do it.
But before going to `TESTING`, we will verify that the deployment event was called.
For this we will create a guard on transitions to `TESTING` state.

[plantuml]
....
[*] --> BACKLOG : time to work!
BACKLOG --> IN_PROGRESS : start feature
IN_PROGRESS --> TESTING : finish feature
TESTING --> DONE : QA approved
TESTING --> IN_PROGRESS : QA rejected task
BACKLOG --> TESTING : Rock Star
BACKLOG --> BACKLOG : deploy
IN_PROGRESS --> IN_PROGRESS : deploy
....

Add transitions for internal `DEPLOY` and guards for transitions to `TESTING`

[source, java]
----
transitions.withExternal()
           .source(States.BACKLOG)
           .target(States.IN_PROGRESS)
           .event(Events.START_FEATURE)
           .and()
           .withExternal()
           .source(States.IN_PROGRESS)
           .target(States.TESTING)
           .event(Events.FINISH_FEATURE)
           .guard(checkDeployGuard()) <1>
           .and()
           .withExternal()
           .source(States.TESTING)
           .target(States.IN_PROGRESS)
           .event(Events.QA_TEAM_REJECT)
           .and()
           .withExternal()
           .source(States.TESTING)
           .target(States.DONE)
           .event(Events.QA_TEAM_APPROVE)
           .and()
           .withExternal()
           .source(States.BACKLOG)
           .target(States.TESTING)
           .guard(checkDeployGuard()) <1>
           .event(Events.ROCK_STAR_MAKE_ALL_IN_ONE)
           .and()

           .withInternal()
           .source(States.BACKLOG)
           .event(Events.DEPLOY) <2>
           .action(deployAction())
           .and()
           .withInternal()
           .source(States.IN_PROGRESS)
           .event(Events.DEPLOY) <2>
           .action(deployAction());
----
<1> guards on transitions to `TESTING`
<2> internal `DEPLOY` events

Then we make guard implementation based on state machine variables.
You can write in extend state a lot of useful things that will be shared in process.

[source, java]
----
private Guard<States, Events> checkDeployGuard() {
    return context -> {
        Boolean flag = (Boolean) context.getExtendedState()
                                        .getVariables()
                                        .get("deployed");
        return flag == null ? false : flag;
    };
}
----

After that, we can use this variable in the deployment action:

[source, java]
----
private Action<States, Events> deployAction() {
    return context -> {
        log.warn("DEPLOYING: {}", context.getEvent());
        context.getExtendedState()
               .getVariables()
               .put("deployed", true);
    };
}
----

Now we can make unit test for this case

[source, java]
----
@Test
public void testGuard() {
    // Arrange & act
    stateMachine.sendEvent(Events.START_FEATURE);
    stateMachine.sendEvent(Events.FINISH_FEATURE);
    stateMachine.sendEvent(Events.QA_TEAM_APPROVE); // not accepted!
    // Asserts
    Assertions.assertThat(stateMachine.getState().getId())
              .isEqualTo(States.IN_PROGRESS);
}
----

If we don't send the `DEPLOY` event then we get the following result:

image::guard_test_result.png[guard test result]

## Persist State machine in-memory

We need to write an implementation of StateMachinePersist.

To start we make a simple (in-memory) implementation:

[source, java]
----
public class InMemoryPersist
        implements StateMachinePersist<States, Events, UUID> {

    private HashMap<UUID, StateMachineContext<States, Events>> storage
            = new HashMap<>(); <1>

    @Override
    public void write(StateMachineContext<States, Events> context,
                      UUID contextObj) throws Exception {

        storage.put(contextObj, context);
    }

    @Override
    public StateMachineContext<States, Events> read(UUID contextObj) throws Exception {
        return storage.get(contextObj);
    }
}
----
<1> to save the state machine we use the HashMap

WARNING: note that the context of the state machine is saved, not the state machine.
The StateCacheContext contains not only the current state,
there are also stored variables that we write to the context.
It provide ability to restore a completely identical state of the state machine.

Than we make a persist configuration:

[source, java]
----
@Bean
public StateMachinePersist<States, Events, UUID> inMemoryPersist() {
    return new InMemoryPersist();
}

@Bean
public StateMachinePersister<States, Events, UUID> persister(
        StateMachinePersist<States, Events, UUID> defaultPersist) {

    return new DefaultStateMachinePersister<>(defaultPersist);
}
----

Now we can use it:

[source, java]
----
@Autowired
private StateMachineFactory<States, Events> stateMachineFactory;

@Autowired
private StateMachinePersister<States, Events, UUID> persister;

@Test
public void testPersist() throws Exception {
	 // Arrange
	 StateMachine<States, Events> firstStateMachine =
					 stateMachineFactory.getStateMachine();

	 StateMachine<States, Events> secondStateMachine =
					 stateMachineFactory.getStateMachine();

	 firstStateMachine.sendEvent(Events.START_FEATURE);
	 firstStateMachine.sendEvent(Events.DEPLOY);

	 // precondition
	 Assertions.assertThat(secondStateMachine.getState().getId())
						 .isEqualTo(States.BACKLOG);

	 // Act
	 persister.persist(firstStateMachine, firstStateMachine.getUuid()); <1>
	 persister.restore(secondStateMachine, firstStateMachine.getUuid()); <2>

	 // Asserts
	 Assertions.assertThat(secondStateMachine.getState().getId())
						 .isEqualTo(States.IN_PROGRESS);
}
----
<1> save first state machine context
<2> load first state machine context to second

## Persist state machine in MongoDb

We need add some dependencies for work with MongoDb.
Also we will write integration tests with TestContainers framework.

[source, mvn]
----
<!-- MongoDB -->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.statemachine</groupId>
	<artifactId>spring-statemachine-data-mongodb</artifactId>
	<version>2.0.0.RELEASE</version>
</dependency>
<!-- MongoDB -->

<!-- TestContainers -->
<dependency>
	<groupId>org.testcontainers</groupId>
	<artifactId>testcontainers</artifactId>
	<version>1.4.3</version>
</dependency>
<!-- TestContainers -->
----

Then we make MongoDb persist

[source, java]
----
@Bean
public StateMachineRuntimePersister<States, Events, UUID> mongoPersist(
        MongoDbStateMachineRepository mongoRepository) {

    return new MongoDbPersistingStateMachineInterceptor<States,Events,UUID>(mongoRepository);
}
----

Now we can make integration test.

I have abstract class for testing mongodb application in spring framework.
The TestContainers library allows us to run the mongodb in docker and use it as a target data base:

[source, java]
----
@SpringBootTest
@RunWith(SpringRunner.class)
public abstract class BaseMongoIT {

    private static final Integer MONGO_PORT = 27017;
    private static GenericContainer mongo =
            new GenericContainer("mongo:latest")
            .withExposedPorts(MONGO_PORT);

    static {
        mongo.start();
        System.setProperty("spring.data.mongodb.host", mongo.getContainerIpAddress());
        System.setProperty("spring.data.mongodb.port", mongo.getMappedPort(MONGO_PORT).toString());
    }

    @Autowired
    protected MongoTemplate mongoTemplate;
}
----

and test case:

[source, java]
----
public class MongoPersistTest extends BaseMongoIT {

    @Autowired
    private StateMachinePersister<States, Events, UUID> persister;
    @Autowired
    private StateMachineFactory<States, Events> stateMachineFactory;

	@Test
    public void testMongoPersist() throws Exception {
        // Arrange
        StateMachine<States, Events> firstStateMachine = stateMachineFactory.getStateMachine();
        StateMachine<States, Events> secondStateMachine = stateMachineFactory.getStateMachine();

        firstStateMachine.sendEvent(Events.START_FEATURE);
        firstStateMachine.sendEvent(Events.DEPLOY);

        // Act
        persister.persist(firstStateMachine, firstStateMachine.getUuid());
        persister.persist(secondStateMachine, secondStateMachine.getUuid());
        persister.restore(secondStateMachine, firstStateMachine.getUuid());

        // Asserts
        Assertions.assertThat(secondStateMachine.getState().getId())
                  .isEqualTo(States.IN_PROGRESS);

        boolean deployed = (boolean) secondStateMachine.getExtendedState()
                                                       .getVariables()
                                                       .get("deployed");

        Assertions.assertThat(deployed).isEqualTo(true);

        // Mongo specific asserts:
        Assertions.assertThat(mongoTemplate.getCollectionNames())
                  .isNotEmpty();

        List<Document> documents = mongoTemplate.findAll(Document.class,
                                                         "MongoDbRepositoryStateMachine");

        Assertions.assertThat(documents).hasSize(2);
        Assertions.assertThat(documents)
                  .flatExtracting(Document::values)
                  .contains(firstStateMachine.getUuid().toString(),
                            secondStateMachine.getUuid().toString())
                  .contains(firstStateMachine.getState().getId().toString(),
                            secondStateMachine.getState().getId().toString());
    }
}
----


## Live without state machines seems boring.

Let's look at several alternative solutions, without using the state machines and consider the pros and cons of them.


### You can hardcode your business logic

It looks like a spaghetti code:

[source, java]
----
    class StateMachine {

        private States currentState;
        private HashMap<String, Object> variables;
        private boolean finished;

        public void processing(Events event) {

            if(!finished) {
                log.error("already finished state machine");
            }

            switch (currentState) {
                case BACKLOG:
                    if (event == Events.START_FEATURE) {
                        currentState = States.IN_PROGRESS;
                        // transition logic
                    } else if (event == Events.DEPLOY) {
                        variables.put("deployed", true);
                        // start deploy
                    } else {
                        log.error("not accepted event.");
                    }
                    break;

                case IN_PROGRESS:
                    if (event == Events.FINISH_FEATURE) {
                        if (variables.get("deployed").equals(true)) {
                            currentState = States.TESTING;
                            // run business logic
                        } else {
                            log.error("unreachable state");
                        }
                        // transition logic
                    } else if (event == Events.DEPLOY) {
                        variables.put("deployed", true);
                        // start deploy
                    } else {
                        log.error("not accepted event.");
                    }
                    break;

                case TESTING:
                    if(event == Events.QA_TEAM_APPROVE){
                        currentState = States.DONE;
                        finished = true;
                        log.info("successful done!");
                    } else if (event == Events.QA_TEAM_REJECT){
                        currentState = States.IN_PROGRESS;
                        log.info("reject");
                    } else {
                        log.error("not accepted event.");
                    }
                    break;

						...

            }
        }
----

Of course, you can work on the organization of this code,
you can replace the repeating logic and make strategies for processing events, etc.
But in the first approximation it is very difficult to maintain this code.
It is difficult to track the logic of the transitions and their availability.

icon:plus[] Pros:

- Speed of implementation, you don't need to create an infrastructure for working with business processes

icon:minus[] Cons:

- Very poor further code maintenance


### The second alternative - you can use any BPM engine

This is a good alternative, but quite expensive.
I will shortly discuss the cost of using the BPM in the project.
First, you will need to deploy a full-fledged framework for BPM processes in the project.
These frameworks are not lightweight, not all of them work natively in java.
Secondly, you need to know BPMN notation and be able to describe your business process using this notation.

image:bpm.png[bpmn]

icon:plus[] You should use BPMN-engine:

- If you have very complex business processes.

- When you need a lot of opportunities provided by the BPM notation,
such as: messages, subprocesses, signals, conditions on any transitions, etc.

- If you need process versioning.

- When you need to visualize the processes by their code.

- When you need tools to view and debug all current processes and their states.

icon:minus[] You should not use BPMN-engine:

- If you have very simple processes and a set of system states is obvious.

- If you have little time to develop and(or) you don't have specialists in this subject area.

- If you do not need to versioning the processes.

- There is no way to deploy a full-fledged BPM framework in production.



## Source code of this project on the github

image:../icons/git.png[github,64,64] link:https://github.com/antkorwin/statemachine[github.com/antkorwin/statemachine]


// END OF CONTENT
include::../metrica.adoc[]

++++
<div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = 'antkorwin.com';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'statemachine'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://antkorwin.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
++++
