= Synchronization by instance of the class
:source-highlighter: prettify
:icons: font
:toc:
:experimental:
:numbered:
:homepage: http://antkorwin.com
Korovin Anatoliy <antkorwin@gmail.com>;  Home <http://antkorwin.com>
// START OF CONTENT

## Intro

Sometimes we need to synchronization some blocks of code by the value of variable, for example Id of the entity:

[source, java]
----
public void withdrawMoney(UUID userId, int amountOfMoney) {
  synchronized (userId) {
      Result result = externalPolicySystem.validateTransfer(userId, amountOfMoney, WITHDRAW);
      if(result.getStatus() != OK) {
        throw new UnreachableTransfer(result);
      }
      accountService.transfer(userId, amountOfMoney, WITHDRAW);
  }
}
----

## Wrong ways to solve this issue

### synchronization on methods

you can move synchronized on method:

[source, java]
----
public synchronized void withdrawMoney(UUID userId, int amountOfMoney) {
    ..
}
----

This solution has bad performance.
You will block the money transfer for absolutely all users.


### String.intern

In order to ensure that the instance of the class with the user ID
is the same in all synchronized blocks,
we can serialize it into a String and use the String.intern().

[source, java]
----
public void withdrawMoney(UUID userId, int amountOfMoney) {
  synchronized (userId.toString().intern()) {
      ..
  }
}
----

Using intern is not good practice, because the pool of Strings is difficult to clean with the GC.
And with the active use of such synchronizations, your application can consume too many resources.

Also, there is a chance that foreign code blocks is synchronized on
the same instance of the string as your application.
This can lead to deadlocks.

In general, the use of intern is better left to the libraries of the JDK,
there are good articles by Aleksey Shipilev about this point.



## Create your own synchronization primitive

We need to implementation of the next diagram:

[plantuml]
....
A -> XSync : lock mutex by **userId **
activate XSync #11DD41
||35|
XSync -> A : release mutex
deactivate XSync

B -> XSync : lock mutex by **userId**
activate XSync #11DD41

A [#red]--> XSync : try to lock by **userId**
activate A #DD3311
note left: wait for \n\
release of \nthe mutex

'A -> A : waiting

XSync -> B : release mutex
deactivate XSync

A -> XSync :\tlock mutex by **userId**
deactivate A
activate XSync #11DD41

XSync -> A : release mutex
deactivate XSync
....

At the first we need to make a synchronization primitive - the custom mutex.
Which will work by the value of the variable, and not by the reference to the object.

Something like this:

[source, java]
----
public void withdrawMoney(UUID userId, int amountOfMoney) {
  synchronized (XMutex.of(userId)) {
      ..
  }
}
----

In order to ensure that the same mutexes are obtained
for equal values of variables, we will make the mutex factory.

[source, java]
----
public void withdrawMoney(UUID userId, int amountOfMoney) {
  synchronized (XMutexFactory.get(userId)) {
      ..
  }
}

public void purchase(UUID userId, int amountOfMoney, VendorDescription vendor) {
  synchronized (XMutexFactory.get(userId)) {
      ..
  }
}
----

In order to implementation this behavior we used WeakReference and WeakHashMap.
I wrote an article about this type of references a week ago, you can consider this in more details here:
link:./weakreference.html[Soft, Weak, Phantom references in Java]

Our mutex factory will be based on the WeakHashMap.
We need to use a synchronized version of WeakHashMap,
let's see what's described in the documentation about it:

"This class is not synchronized. A synchronized WeakHashMap may be constructed using the Collections.synchronizedMap method"


The mutex factory creates a new mutex only
if the mutex for this value(key) is not found in the HashMap.
Then created mutex is added to the HashMap.
Using of the WeakHashMap allows us to store a mutex in the HashMap while exist any references to it
And the mutex will be removed from HashMap automatically when all references to it are released.

[source, java]
----
public XMutex<KeyT> getMutex(KeyT key) {
    synchronized (weakHashMap) {
        validateKey(key);
        return getExist(key)
                .orElseGet(() -> saveNewReference(key));
    }
}

private Optional<XMutex<KeyT>> getExist(KeyT key) {
    return Optional.ofNullable(weakHashMap.get(XMutex.of(key)))
                   .map(WeakReference::get);
}

private XMutex<KeyT> saveNewReference(KeyT key) {

    XMutex<KeyT> mutex = XMutex.of(key);

    WeakReference<XMutex<KeyT>> res = weakHashMap.put(mutex, new WeakReference<>(mutex));
    if (res != null && res.get() != null) {
        return res.get();
    }
    return mutex;
}
----

## XSync library

I wrapped this code into the XSync library,
and you can use it as ready solution for the synchronization on value of variable.

In order to do it, you need to add dependencies:

[source , xml]
----
<repositories>
	<repository>
		<id>jitpack.io</id>
		<url>https://jitpack.io</url>
	</repository>
</repositories>

<dependency>
	<groupId>com.github.antkorwin</groupId>
	<artifactId>xsync</artifactId>
	<version>0.4</version>
</dependency>
----



## Concurrency tests



## XSync library on github, issue requests are welcome

image:../icons/git.png[github,64,64] https://github.com/antkorwin/xsync[github.com/antkorwin/xsync]




// END OF CONTENT
include::../metrica.adoc[]

++++
<div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = 'antkorwin.com';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'sync_by_instance'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://antkorwin.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
++++
