= Synchronization by the instance of the class
:source-highlighter: prettify
:icons: font
:toc:
:experimental:
:numbered:
:homepage: http://antkorwin.com
Korovin Anatoliy <antkorwin@gmail.com>;  Home <http://antkorwin.com>
// START OF CONTENT

## Intro

Sometimes we need to synchronization some blocks of code by the value of variable, for example on Id of the entity:

[source, java]
----
public void withdrawMoney(UUID userId, int amountOfMoney) {
  synchronized (userId) {
      Result result = externalPolicySystem.validateTransfer(userId, amountOfMoney, WITHDRAW);
      if(result.getStatus() != OK) {
        throw new UnreachableTransfer(result);
      }
      accountService.transfer(userId, amountOfMoney, WITHDRAW);
  }
}
----

## Wrong ways to solve this issue

### Synchronization on methods

You can move synchronized on method:

[source, java]
----
public synchronized void withdrawMoney(UUID userId, int amountOfMoney) {
    ..
}
----

This solution has bad performance.
You will block transfers of money for absolutely all users.


### String intern

In order to ensure that the instance of the class (which contain a user ID)
will be the same in all synchronized blocks,
we can serialize it into a String and use the String.intern() for obtain a same link for equals strings.

[source, java]
----
public void withdrawMoney(UUID userId, int amountOfMoney) {
  synchronized (userId.toString().intern()) {
      ..
  }
}
----

Using intern is not good practice, because the pool of Strings is difficult to clean with the GC.
And with the active use of such synchronizations, your application can consume too many resources.

Also, there is a chance that foreign code blocks is synchronized on
the same instance of the string as your application.
This can lead to deadlocks.

In general, the use of intern is better left to the libraries of the JDK,
there are good articles by link:https://shipilev.net[Aleksey Shipilev] about this point.



## A right way: Create your own synchronization primitive

We need to implement a behavior that describes on the next diagram:

[plantuml]
....
A -> XSync : lock mutex by **userId **
activate XSync #11DD41
||35|
XSync -> A : release mutex
deactivate XSync

B -> XSync : lock mutex by **userId**
activate XSync #11DD41

A [#red]--> XSync : try to lock by **userId**
activate A #DD3311
note left: wait for \n\
release of \nthe mutex

'A -> A : waiting

XSync -> B : release mutex
deactivate XSync

A -> XSync :\tlock mutex by **userId**
deactivate A
activate XSync #11DD41

XSync -> A : release mutex
deactivate XSync
....

At the first we need to make a new synchronization primitive - the custom mutex.
Which will work by the value of the variable, and not by the reference to the object.

Something like this:

[source, java]
----
public void withdrawMoney(UUID userId, int amountOfMoney) {
  synchronized (XMutex.of(userId)) {
      ..
  }
}
----

In order to ensure that the same mutexes are obtained
for equal values of variables, we will make the mutex factory.

[source, java]
----
public void withdrawMoney(UUID userId, int amountOfMoney) {
  synchronized (XMutexFactory.get(userId)) {
      ..
  }
}

public void purchase(UUID userId, int amountOfMoney, VendorDescription vendor) {
  synchronized (XMutexFactory.get(userId)) {
      ..
  }
}
----

In order to implement this behavior, we used WeakReference and WeakHashMap.
I wrote an article about this type of references a week ago, you can consider this in more details here:
link:./weakreference.html[Soft, Weak, Phantom references in Java]

Our mutex factory will be based on the WeakHashMap.
We need to use a synchronized version of WeakHashMap,
let's see what's described in the link:https://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html[documentation] about it:

----
This class is not synchronized. A synchronized WeakHashMap may be constructed
using the Collections.synchronizedMap method.
----


The mutex factory creates a new mutex only
if the mutex for this value(key) is not found in the HashMap.
Then created mutex is added to the HashMap.
Using of the WeakHashMap allows us to store a mutex in the HashMap while exist any references to it.
And the mutex will be removed from HashMap automatically when all references to it are released.

[source, java]
----
public XMutex<KeyT> getMutex(KeyT key) {
    synchronized (weakHashMap) {
        validateKey(key);
        return getExist(key)
                .orElseGet(() -> saveNewReference(key));
    }
}

private Optional<XMutex<KeyT>> getExist(KeyT key) {
    return Optional.ofNullable(weakHashMap.get(XMutex.of(key)))
                   .map(WeakReference::get);
}

private XMutex<KeyT> saveNewReference(KeyT key) {

    XMutex<KeyT> mutex = XMutex.of(key);

    WeakReference<XMutex<KeyT>> res = weakHashMap.put(mutex, new WeakReference<>(mutex));
    if (res != null && res.get() != null) {
        return res.get();
    }
    return mutex;
}
----

## Getting started with XSync library

I packed this code into the https://github.com/antkorwin/xsync[XSync] library,
and you can use it as a ready solution for the synchronization on value of variable.

In order to do it, you need to add next dependencies:

[source , xml]
----
<repositories>
	<repository>
		<id>jitpack.io</id>
		<url>https://jitpack.io</url>
	</repository>
</repositories>

<dependency>
	<groupId>com.github.antkorwin</groupId>
	<artifactId>xsync</artifactId>
	<version>0.4</version>
</dependency>
----

Then you be able to create instances of the XSync class for a synchronization on types that you need.
For the Spring Framework you can make them as beans:

[source, java]
----
@Bean
public XSync<UUID> xSync(){
    return new XSync<>();
}
----

And now, you can use it:

[source, java]
----
@Autowired
private XSync<UUID> xSync;

public void withdrawMoney(UUID userId, int amountOfMoney) {
  xSync.execute(userId, () -> {
      Result result = externalPolicySystem.validateTransfer(userId, amountOfMoney, WITHDRAW);
      accountService.transfer(userId, amountOfMoney, WITHDRAW);
  });
}

public void purchase(UUID userId, int amountOfMoney, VendorDescription vendor) {
  xSync.execute(userId, () -> {
      ..
  });
}
----


## Concurrent tests

In order to be sure that this code works well, I wrote several concurrent tests.

There is an example of one of these tests:

[source, java]
----
public void testSyncBySingleKeyInConcurrency() {
   // Arrange
   XSync<UUID> xsync = new XSync<>(); <1>
   String id = UUID.randomUUID().toString();
   NonAtomicInt var = new NonAtomicInt(0);

   // Act
   IntStream.range(0, THREAD_CNT)
            .boxed()
            .parallel()
            .forEach(j -> xsync.execute(UUID.fromString(id), var::increment));  <2>

   // Asserts
   await().atMost(5, TimeUnit.SECONDS)
          .until(var::getValue, equalTo(THREAD_CNT));

   Assertions.assertThat(var.getValue()).isEqualTo(THREAD_CNT);
}

@Getter
@AllArgsConstructor
private class NonAtomicInt {  <3>
    private int value;

    public int increment() {
        return value++;
    }
}
----
<1> Create a XSync instance for a synchronization by UUID value.
<2> There is a magic here, we created a parallel stream
and try to increment the same nonatomic integer variable in the each stream.
<3> Implementation of the not thread safe integer variable.

Let's see at the result of the test:

image:./concurrent_test.png[concurrent test result]


## XSync library on github

image:../icons/git.png[github,64,64] https://github.com/antkorwin/xsync[github.com/antkorwin/xsync]

issue requests and pull-requests are welcome.




// END OF CONTENT
include::../metrica.adoc[]

++++
<div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = 'antkorwin.com';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'sync_by_instance'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://antkorwin.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
++++
